<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>EAIM ë§ˆìŠ¤í„° í•©ì£¼ì‹¤ (Final)</title>
    <style>
        body {
            background-color: #121212; color: #fff;
            font-family: 'Pretendard', sans-serif;
            display: flex; flex-direction: column; align-items: center; padding: 20px;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
        }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #startBtn {
            padding: 30px 80px; font-size: 28px; background: #6200ea; color: white; border: none;
            border-radius: 60px; cursor: pointer; box-shadow: 0 0 60px #6200ea; font-weight: bold;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }

        h1 { color: #00e676; margin-bottom: 5px; text-shadow: 0 0 10px #00e676; text-align: center; }
        .subtitle { color: #aaa; margin-bottom: 20px; font-size: 16px; text-align: center; }

        .emotion-panel { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }
        .emo-btn {
            padding: 10px 20px; border: 2px solid #00e676; background: transparent; color: #00e676;
            border-radius: 30px; cursor: pointer; font-weight: bold; transition: 0.2s; font-size: 15px;
        }
        .emo-btn:hover, .emo-btn.selected { background: #00e676; color: #003300; box-shadow: 0 0 25px #00e676; }

        .tempo-control {
            background: #222; padding: 10px 25px; border-radius: 30px; border: 1px solid #444;
            display: flex; align-items: center; gap: 15px; margin-bottom: 20px;
        }
        .tempo-label { font-size: 16px; font-weight: bold; color: #ffeb3b; min-width: 110px; text-align: center; }
        input[type=range] { width: 150px; accent-color: #ffeb3b; cursor: pointer; }

        #sectionInfo { color: #aaa; font-size: 16px; margin-bottom: 5px; text-align: center; }
        #statusMsg { color: #00e676; font-size: 18px; margin-bottom: 15px; height: 24px; text-align: center; font-weight: bold; }

        .chord-display { display: flex; gap: 15px; margin-bottom: 25px; justify-content: center; }
        .chord-wrapper { position: relative; width: 80px; height: 90px; display: flex; flex-direction: column; align-items: center; }
        .chord-box {
            width: 80px; height: 80px; display: flex; align-items: center; justify-content: center;
            border: 3px solid #444; border-radius: 15px; font-size: 24px; font-weight: bold;
            background: #1e1e1e; color: #777; transition: 0.2s; cursor: pointer; z-index: 2;
        }
        .chord-box.active { border-color: #6200ea; background-color: #2a2a2a; color: white; transform: scale(1.1); box-shadow: 0 0 30px #6200ea; }
        .chord-box.recorded { border-color: #00e676; color: #00e676; box-shadow: inset 0 0 10px #003300; }
        .progress-bg { position: absolute; bottom: 0; left: 0; width: 100%; height: 6px; background: #333; border-radius: 0 0 10px 10px; overflow: hidden; }
        .progress-fill { width: 0%; height: 100%; background: #ffff00; transition: width 0.05s linear; }

        .piano { 
            display: flex; position: relative; background: #222; padding: 20px; 
            border-radius: 15px; margin-bottom: 30px; box-shadow: 0 20px 50px rgba(0,0,0,0.5); 
            overflow-x: auto;
        }
        .key { width: 45px; height: 200px; background: white; border-radius: 0 0 5px 5px; margin: 0 2px; position: relative; z-index: 1; cursor: pointer; transition: 0.05s; flex-shrink: 0; }
        .key.active { background: #bbb; transform: translateY(4px); }
        
        /* â˜… ê±´ë°˜ ëª¨ì–‘ ë° ìœ„ì¹˜ ìˆ˜ì •ë¨ â˜… */
        .key.black { 
            width: 32px; 
            height: 125px; 
            background: linear-gradient(180deg, #111 0%, #333 100%); 
            position: absolute; 
            z-index: 2; 
            top: 0; 
            border: 1px solid #000; 
            border-radius: 0 0 5px 5px; 
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5); 
        }
        .key.black.active { background: #000; transform: translateY(4px); box-shadow: none; }

        .key[data-note="C#"] { left: 54px; } 
        .key[data-note="D#"] { left: 103px; } 
        .key[data-note="F#"] { left: 201px; } 
        .key[data-note="G#"] { left: 250px; } 
        .key[data-note="A#"] { left: 299px; } 
        .key[data-note="C#2"] { left: 397px; margin-left: 0; }
        
        /* â˜… ê°ì • ê°€ì´ë“œ ë¼ì´íŠ¸ CSS â˜… */
        .key.guide-red { background-color: #ff5252 !important; box-shadow: 0 0 15px #ff5252; } 
        .key.guide-yellow { background-color: #ffea00 !important; box-shadow: 0 0 15px #ffea00; } 
        .key.guide-blue { background-color: #448aff !important; box-shadow: 0 0 15px #448aff; } 
        .key.guide-purple { background-color: #e040fb !important; box-shadow: 0 0 15px #e040fb; } 
        
        .key.magic-hit { background-color: #d500f9 !important; box-shadow: 0 0 30px #d500f9; transform: translateY(4px); }

        .control-panel { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 20px; max-width: 800px; }
        button { border: none; font-family: 'Pretendard'; font-weight: bold; padding: 12px 20px; border-radius: 40px; font-size: 15px; cursor: pointer; transition: 0.2s; }
        button:active { transform: scale(0.95); }
        
        .rec-btn { background: #d81b60; color: white; min-width: 220px; }
        .rec-btn.recording { background: #ff0000; animation: blink 1s infinite; box-shadow: 0 0 30px red; }
        .rec-btn.standby { background: #ff9100; color: white; animation: pulse 1s infinite; }
        .rec-btn.finish { background: #4caf50; color: white; }
        @keyframes blink { 50% { opacity: 0.6; } }
        
        .autotune-btn { background: #333; color: #aaa; border: 2px solid #555; }
        .autotune-btn.on { background: linear-gradient(135deg, #00e676, #00c853); color: #003300; border: none; box-shadow: 0 0 30px #00e676; transform: scale(1.05); }
        .add-btn { background: #6200ea; color: white; box-shadow: 0 0 20px #6200ea; }
        .magic-btn { background: linear-gradient(135deg, #2979ff, #2962ff); color: white; box-shadow: 0 0 20px #2962ff; }
        .play-btn { background: #00c853; color: white; box-shadow: 0 0 20px #00c853; }
        .reset-btn { background: #424242; color: #ccc; }
        .save-btn { background: #455a64; color: white; }

        .inquiry-section { width: 90%; max-width: 600px; background: #1e1e1e; padding: 20px; border-radius: 20px; color: #ccc; margin-bottom: 30px; }
        textarea { width: 95%; height: 60px; background: #121212; border: 1px solid #444; color: white; padding: 10px; border-radius: 10px; margin-top: 10px; font-size: 16px; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>ğŸ¸ EAIM ë§ˆìŠ¤í„° í•©ì£¼ì‹¤</h1>
        <p style="color:#bbb; margin-bottom:40px;">ê±´ë°˜ ë¶ˆë¹›ì€ í•­ìƒ ì¼œì ¸ ìˆìŠµë‹ˆë‹¤.</p>
        <button id="startBtn" onclick="appStart()">ğŸ¹ ì…ì¥í•˜ê¸°</button>
    </div>

    <h1>ğŸ¸ EAIM ë§ˆìŠ¤í„° í•©ì£¼ì‹¤</h1>
    <div class="subtitle">ê±´ë°˜ì˜ ìƒ‰ê¹”ì„ ë³´ë©° ë‚˜ë§Œì˜ ë©œë¡œë””ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”.</div>

    <div class="emotion-panel">
        <button class="emo-btn" onclick="setMood('happy')">ğŸ˜„ í–‰ë³µ</button>
        <button class="emo-btn" onclick="setMood('sad')">ğŸ˜¢ ìŠ¬í””</button>
        <button class="emo-btn" onclick="setMood('dreamy')">â˜ï¸ ëª½í™˜</button>
        <button class="emo-btn" onclick="setMood('excited')">ğŸ˜† ì‹ ë‚¨</button>
        <button class="emo-btn" onclick="setMood('love')">ğŸ¥° ì‚¬ë‘</button>
    </div>

    <div class="tempo-control">
        <div class="tempo-label" id="bpmLabel">ì†ë„: 80 BPM</div>
        <input type="range" min="60" max="140" value="80" step="5" oninput="changeTempo(this.value)">
    </div>

    <div id="sectionInfo">í˜„ì¬ êµ¬ê°„: 1ì ˆ (Part A)</div>
    <div id="statusMsg">ì¤€ë¹„ë¨ (1ë²ˆ ë§ˆë”” ë…¹ìŒì„ ì‹œì‘í•˜ì„¸ìš”)</div>

    <div class="chord-display" id="chordContainer"></div>

    <div class="piano">
        <div class="key" data-note="C"></div> <div class="key black" data-note="C#"></div>
        <div class="key" data-note="D"></div> <div class="key black" data-note="D#"></div>
        <div class="key" data-note="E"></div> <div class="key" data-note="F"></div>
        <div class="key black" data-note="F#"></div> <div class="key" data-note="G"></div>
        <div class="key black" data-note="G#"></div> <div class="key" data-note="A"></div>
        <div class="key black" data-note="A#"></div> <div class="key" data-note="B"></div>
        <div class="key" data-note="C2"></div> <div class="key black" data-note="C#2"></div>
        <div class="key" data-note="D2"></div>
    </div>

    <div class="control-panel">
        <button id="recBtn" class="rec-btn" onclick="prepareRecordingStep()">ğŸ”´ 1ë²ˆ ë§ˆë”” ë…¹ìŒ ì¤€ë¹„</button>
        <button id="addSectionBtn" class="add-btn" onclick="addNewSection()" style="display:none;">â• 4ë§ˆë”” ë” ì¶”ê°€í•˜ê¸°</button>
        
        <button id="autoTuneBtn" class="autotune-btn" onclick="toggleAutoTune()">ğŸª„ í”„ë¡œë“€ì„œ ë„ê¹¨ë¹„</button>
        <button class="magic-btn" onclick="applySmartRhythm()">âš¡ ë¦¬ë“¬ ì •ë¦¬</button>
        <button class="play-btn" onclick="playEnsemble()">â–¶ ì „ì²´ ê³¡ ë“£ê¸°</button>
        <button class="reset-btn" onclick="resetAll()">ğŸ”„ ë¦¬ì…‹</button>
        <button class="save-btn" onclick="exportAudio()">ğŸ’¾ ì €ì¥</button>
    </div>

    <div class="inquiry-section">
        <h3>ğŸ“ ë‚˜ì˜ ìŒì•… ì¼ì§€</h3>
        <label>1. ë¹¨ê°„ìƒ‰(ì•ˆì •)ê³¼ íŒŒë€ìƒ‰(ì„¸ë ¨) ì¤‘ ì–´ë–¤ ìŒì„ ë” ë§ì´ ì¼ë‚˜ìš”?</label>
        <textarea id="q1"></textarea>
        <div style="text-align: right; margin-top:10px;">
            <button class="save-btn" onclick="saveLog()" style="padding:8px 20px; font-size:14px;">ğŸ“„ ì¼ì§€ ì €ì¥</button>
        </div>
    </div>

    <script>
        let audioCtx, masterGain, destNode, compressor, reverbNode;
        let bandGain, melodyGain;
        let currentChords = [], melodyData = []; 
        let isAutoTune = false, isRecording = false, isStandby = false;
        let recStartTime = 0;
        let isPlaying = false, recordTimerInterval = null, playTimerInterval = null;
        let currentStep = 0; 
        let sectionCount = 0; 
        let scheduledEvents = [];
        let currentMood = 'happy';

        let BPM = 80;
        let BEAT_TIME = 60 / BPM; 
        let BAR_TIME = BEAT_TIME * 4;
        let QUANTIZE_GRID = BEAT_TIME / 4;

        const chordsData = {
            'happy': ['C', 'G', 'Am', 'F'], 
            'sad': ['Am', 'F', 'C', 'G'],
            'dreamy': ['F', 'G', 'Em', 'Am'], 
            'excited': ['C', 'F', 'G', 'C'],
            'love': ['F', 'G', 'C', 'Am']
        };
        const notesScale = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        function appStart() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            compressor = audioCtx.createDynamicsCompressor();
            masterGain = audioCtx.createGain(); masterGain.gain.value = 0.9;
            reverbNode = audioCtx.createConvolver();
            createReverbImpulse(1.5); 
            bandGain = audioCtx.createGain(); bandGain.gain.value = 1.0;
            melodyGain = audioCtx.createGain(); melodyGain.gain.value = 1.0;
            bandGain.connect(masterGain); melodyGain.connect(masterGain);
            destNode = audioCtx.createMediaStreamDestination();
            masterGain.connect(compressor); compressor.connect(audioCtx.destination); compressor.connect(destNode);
            document.getElementById('overlay').style.display = 'none';
            setMood('happy');
            if(audioCtx.state === 'suspended') audioCtx.resume();
        }

        function createReverbImpulse(duration) {
            let rate = audioCtx.sampleRate; let length = rate * duration;
            let impulse = audioCtx.createBuffer(2, length, rate);
            let left = impulse.getChannelData(0); let right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                let decay = Math.pow(1 - i / length, 2);
                let leftVal = (Math.random() * 2 - 1) * decay;
                let rightVal = (Math.random() * 2 - 1) * decay;
                left[i] = leftVal; right[i] = rightVal;
            }
            reverbNode.buffer = impulse;
        }

        function changeTempo(val) {
            let newBPM = parseInt(val);
            document.getElementById('bpmLabel').innerText = `ì†ë„: ${newBPM} BPM`;
            let ratio = BPM / newBPM;
            BPM = newBPM; BEAT_TIME = 60 / BPM; BAR_TIME = BEAT_TIME * 4; QUANTIZE_GRID = BEAT_TIME / 4;
            melodyData.forEach(m => { m.relStart *= ratio; m.duration *= ratio; });
            stopEverything();
            updateMsg(`ì†ë„ ${newBPM} BPMìœ¼ë¡œ ë³€ê²½ë¨.`);
        }

        function setMood(mood) {
            if(!audioCtx) return;
            currentMood = mood;
            document.querySelectorAll('.emo-btn').forEach(b => b.classList.remove('selected'));
            let btns = document.querySelectorAll('.emo-btn');
            for(let b of btns) { if(b.innerText.includes(mood=='love'?'ì‚¬ë‘':(mood=='happy'?'í–‰ë³µ':(mood=='sad'?'ìŠ¬í””':(mood=='dreamy'?'ëª½í™˜':'ì‹ ë‚¨'))))) b.classList.add('selected'); }

            currentChords = chordsData[mood];
            resetAll();
            renderChords();
            showGuide(currentChords[0], 0);
            updateMsg(`'${mood}' ëª¨ë“œ ì„ íƒë¨. (ê±´ë°˜ ìƒ‰ê¹”ì„ í™•ì¸í•˜ì„¸ìš”!)`);
        }

        function renderChords() {
            const container = document.getElementById('chordContainer');
            container.innerHTML = '';
            currentChords.forEach((chord, idx) => {
                const wrapper = document.createElement('div'); wrapper.className = 'chord-wrapper';
                const box = document.createElement('div'); box.className = 'chord-box';
                box.innerText = chord; box.id = `chord-${idx}`;
                box.onclick = () => { if(audioCtx) playGuitarStrum(chord, audioCtx.currentTime); showGuide(chord, idx); };
                const bg = document.createElement('div'); bg.className = 'progress-bg';
                const fill = document.createElement('div'); fill.className = 'progress-fill'; fill.id = `prog-${idx}`;
                bg.appendChild(fill); wrapper.appendChild(box); wrapper.appendChild(bg);
                container.appendChild(wrapper);
            });
        }

        function resetAll() {
            stopEverything();
            melodyData = [];
            currentStep = 0;
            sectionCount = 0;
            document.getElementById('sectionInfo').innerText = "í˜„ì¬ êµ¬ê°„: 1ì ˆ (Part A)";
            document.getElementById('addSectionBtn').style.display = 'none';
            document.querySelectorAll('.progress-fill').forEach(el => el.style.width = '0%');
            document.querySelectorAll('.chord-box').forEach(el => el.classList.remove('recorded', 'active'));
            updateRecButtonState();
            updateMsg("ì´ˆê¸°í™” ì™„ë£Œ.");
            showGuide(currentChords[0], 0);
        }

        function stopEverything() {
            if(recordTimerInterval) clearInterval(recordTimerInterval);
            scheduledEvents.forEach(node => { try{node.stop()}catch(e){} });
            scheduledEvents = [];
            isRecording = false; isStandby = false; isPlaying = false;
            updateRecButtonState();
        }

        function updateRecButtonState() {
            const btn = document.getElementById('recBtn');
            btn.className = 'rec-btn';
            btn.style.display = 'inline-block';
            if (currentStep < 4) {
                btn.innerText = `ğŸ”´ ${currentStep + 1}ë²ˆ ë§ˆë”” ë…¹ìŒ ì¤€ë¹„`;
                document.getElementById('addSectionBtn').style.display = 'none';
            } else {
                btn.classList.add('finish');
                btn.innerText = "âœ… í˜„ì¬ êµ¬ê°„ ì™„ë£Œ";
                btn.style.display = 'none';
                document.getElementById('addSectionBtn').style.display = 'inline-block';
            }
        }

        function addNewSection() {
            sectionCount++;
            currentStep = 0;
            document.getElementById('sectionInfo').innerText = `í˜„ì¬ êµ¬ê°„: ${sectionCount + 1}ì ˆ (Part ${String.fromCharCode(65+sectionCount)})`;
            document.querySelectorAll('.chord-box').forEach(el => el.classList.remove('recorded', 'active'));
            document.querySelectorAll('.progress-fill').forEach(el => el.style.width = '0%');
            updateRecButtonState();
            updateMsg(`ğŸ‰ ${sectionCount+1}ì ˆ ì‹œì‘!`);
            showGuide(currentChords[0], 0);
        }

        // === ìŠ¤ë§ˆíŠ¸ ë¦¬ë“¬ ===
        function applySmartRhythm() {
            if(melodyData.length===0) return updateMsg("âš ï¸ ë…¹ìŒëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
            melodyData.sort((a, b) => a.relStart - b.relStart);
            let uniqueData = []; let lastTime = -1;

            melodyData.forEach(m => {
                let timeInPattern = m.relStart % (BAR_TIME * 4);
                let measureIndex = Math.floor(timeInPattern / BAR_TIME); 
                let beatInMeasure = (timeInPattern % BAR_TIME) / BEAT_TIME;
                
                // 1,3ë§ˆë””ì˜ 1~2ë°•(ì•ë¶€ë¶„)ì€ Straight(ì •ë°•)
                let isStraightZone = (measureIndex === 0 || measureIndex === 2) && beatInMeasure < 2.0;
                let adjustedTime = m.relStart;
                if (!isStraightZone) {
                    adjustedTime = applySoftSyncopation(m.relStart);
                }

                let snappedTime = Math.round(adjustedTime / QUANTIZE_GRID) * QUANTIZE_GRID;
                if(snappedTime < 0) snappedTime = 0;

                if (Math.abs(snappedTime - lastTime) > 0.05) { 
                    m.relStart = snappedTime;
                    if(isAutoTune) m.note = getSmartSafeNote(m.note, snappedTime);
                    uniqueData.push(m);
                    lastTime = snappedTime;
                }
            });
            melodyData = uniqueData;
            playSynthLead("C5", audioCtx.currentTime, 0.1); 
            updateMsg("âš¡ ë¦¬ë“¬ ì •ë¦¬ ì™„ë£Œ! (ì•ˆì •ê° + ê·¸ë£¨ë¸Œ)");
        }

        function applySoftSyncopation(originalTime) {
            let offset = originalTime % BEAT_TIME;
            if (offset > (BEAT_TIME * 0.6)) return originalTime - (BEAT_TIME * 0.15); 
            return originalTime;
        }

        function showGuide(chord, idx) {
            document.querySelectorAll('.chord-box').forEach(b => b.classList.remove('active'));
            if(document.getElementById(`chord-${idx}`)) document.getElementById(`chord-${idx}`).classList.add('active');
            
            document.querySelectorAll('.key').forEach(k => k.classList.remove('guide-red', 'guide-yellow', 'guide-blue', 'guide-purple', 'guide-good'));
            
            let root = chord.replace('m','');
            let isMinor = chord.includes('m');
            let rootIdx = notesScale.indexOf(root);

            if (currentMood === 'happy' || currentMood === 'excited' || currentMood === 'love') {
                let redSteps = isMinor ? [0, 7] : [0, 7];
                redSteps.forEach(s => light(notesScale[(rootIdx+s)%12], 'guide-red'));
                let yellowSteps = isMinor ? [3] : [4];
                yellowSteps.forEach(s => light(notesScale[(rootIdx+s)%12], 'guide-yellow'));
            } 
            else if (currentMood === 'dreamy' || currentMood === 'sad') {
                let blueSteps = isMinor ? [2, 10] : [2, 9]; 
                blueSteps.forEach(s => light(notesScale[(rootIdx+s)%12], 'guide-blue'));
                let purpleSteps = isMinor ? [7] : [11];
                if(!isMinor) purpleSteps = [11]; 
                purpleSteps.forEach(s => light(notesScale[(rootIdx+s)%12], 'guide-purple'));
                light(notesScale[(rootIdx)%12], 'guide-red'); 
            }
        }
        function light(n, cls) { 
            document.querySelectorAll(`.key[data-note^="${n}"]`).forEach(k => { 
                if(k.getAttribute('data-note').replace('2','')===n) k.classList.add(cls); 
            }); 
        }

        function getSmartSafeNote(playedNote, timeInSong) {
            if (!isAutoTune) return playedNote;
            let barIndex = Math.floor((timeInSong % (BAR_TIME*4)) / BAR_TIME);
            let chord = currentChords[barIndex];
            if(!chord) return playedNote;
            let root = chord.replace('m', '');
            let isMinor = chord.includes('m');
            let rootIdx = notesScale.indexOf(root);
            
            let steps = isMinor ? [0, 2, 3, 7, 10] : [0, 2, 4, 7, 9];
            let safeNotes = steps.map(s => notesScale[(rootIdx+s)%12]);
            let char = playedNote.replace(/[0-9]/g, '');
            let oct = playedNote.replace(/[^0-9]/g, '');
            if(safeNotes.includes(char)) return playedNote; 
            let chordTonesSteps = isMinor ? [0, 3, 7] : [0, 4, 7];
            let chordTones = chordTonesSteps.map(s => notesScale[(rootIdx+s)%12]);
            let pick = chordTones[Math.floor(Math.random() * chordTones.length)];
            return pick + oct;
        }

        function playSynthLead(note, time, duration) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            osc.type = 'sawtooth'; osc.frequency.value = getFreq(note);
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, time);
            filter.frequency.linearRampToValueAtTime(3000, time + 0.1); 
            const reverbSend = audioCtx.createGain(); reverbSend.gain.value = 0.3;
            osc.connect(filter); filter.connect(gain);
            gain.connect(melodyGain); gain.connect(reverbSend); 
            reverbSend.connect(reverbNode); reverbNode.connect(masterGain);
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.7, time + 0.05); 
            osc.start(time);
            let playDur = Math.max(duration, 0.25); 
            gain.gain.setTargetAtTime(0, time + playDur - 0.1, 0.2); 
            osc.stop(time + playDur + 0.5);
            scheduledEvents.push(osc);
            return { osc, gain };
        }

        function prepareRecordingStep() {
            if(!audioCtx) appStart();
            stopEverything(); 
            if(currentStep >= 4) return updateMsg("4ë§ˆë”” ì™„ë£Œ! 'ì „ì²´ ê³¡ ë“£ê¸°'ë¥¼ ëˆ„ë¥´ì„¸ìš”.");
            isStandby = true;
            const btn = document.getElementById('recBtn');
            btn.classList.add('standby'); 
            btn.innerText = `âœ‹ ê±´ë°˜ ëˆ„ë¥´ë©´ ${currentStep+1}ë§ˆë”” ì‹œì‘`;
            updateMsg(`âœ‹ [${sectionCount+1}ì ˆ] ${currentStep+1}ë²ˆ ë§ˆë”” ëŒ€ê¸° ì¤‘...`);
            showGuide(currentChords[currentStep], currentStep);
            if(audioCtx.state === 'suspended') audioCtx.resume();
        }

        function startRecordingStep() {
            recStartTime = audioCtx.currentTime; 
            const btn = document.getElementById('recBtn');
            btn.classList.remove('standby'); btn.classList.add('recording');
            btn.innerText = `â¹ ${currentStep+1}ë²ˆ ë§ˆë”” ë…¹ìŒ...`;
            playDrum('hat', recStartTime); 
            document.querySelectorAll('.chord-box').forEach(b => b.classList.remove('active'));
            document.getElementById(`chord-${currentStep}`).classList.add('active');
            recordTimerInterval = setInterval(() => {
                let now = audioCtx.currentTime;
                let elapsed = now - recStartTime;
                let progress = (elapsed / BAR_TIME) * 100;
                let fill = document.getElementById(`prog-${currentStep}`);
                if(fill) fill.style.width = `${Math.min(progress, 100)}%`;
                if (elapsed >= BAR_TIME) finishRecordingStep();
            }, 50);
        }

        function finishRecordingStep() {
            clearInterval(recordTimerInterval);
            isRecording = false; isStandby = false;
            document.getElementById(`chord-${currentStep}`).classList.remove('active');
            document.getElementById(`chord-${currentStep}`).classList.add('recorded');
            currentStep++;
            updateRecButtonState();
            if(currentStep < 4) {
                updateMsg(`âœ… ${currentStep}ë²ˆ ë§ˆë”” ì™„ë£Œ!`);
                showGuide(currentChords[currentStep], currentStep);
            } else {
                updateMsg(`ğŸ‰ ${sectionCount+1}ì ˆ ì™„ì„±! 'â• 4ë§ˆë”” ì¶”ê°€' ê°€ëŠ¥.`);
            }
        }

        // â˜…â˜…â˜… ìˆ˜ì •ëœ í•©ì£¼ ì¬ìƒ í•¨ìˆ˜ (ê°ì •ë³„ ì£¼ë²• ë³€í™” ì ìš©) â˜…â˜…â˜…
        async function playEnsemble() {
            stopEverything();
            if(melodyData.length===0) return updateMsg("âš ï¸ ë°ì´í„° ì—†ìŒ");
            if(audioCtx.state === 'suspended') await audioCtx.resume();

            isPlaying = true;
            let maxTime = 0; melodyData.forEach(m => { if(m.relStart > maxTime) maxTime = m.relStart; });
            let totalDuration = Math.ceil(Math.max(maxTime, 0.1) / (BAR_TIME*4)) * (BAR_TIME*4);
            if (totalDuration < BAR_TIME*4) totalDuration = BAR_TIME*4;

            // ê°ì •ì— ë”°ë¼ ì•ˆë‚´ ë©”ì‹œì§€ì™€ ì—°ì£¼ ëª¨ë“œ ì„¤ì •
            let isSoftMode = (currentMood === 'sad' || currentMood === 'dreamy');
            updateMsg(`ğŸ¶ ${isSoftMode ? 'ê°ì„±ì ì¸ ì•„ë¥´í˜ì§€ì˜¤' : 'ê²½ì¾Œí•œ ë¦¬ë“¬'}ë¡œ í•©ì£¼ ì¤‘...`);
            
            let masterStartTime = audioCtx.currentTime + 0.1;

            for (let t = 0; t < totalDuration; t += (BAR_TIME * 4)) {
                currentChords.forEach((chord, i) => {
                    let start = masterStartTime + t + (i * BAR_TIME);
                    let root = chord.replace('m','');
                    
                    // ì‹œê° íš¨ê³¼
                    setTimeout(() => {
                        if(!isPlaying) return;
                        let currentSecIdx = Math.floor((audioCtx.currentTime - masterStartTime) / (BAR_TIME*4));
                        document.getElementById('sectionInfo').innerText = `ì¬ìƒ ì¤‘: ${currentSecIdx + 1}ì ˆ`;
                        showGuide(chord, i);
                        let fill = document.getElementById(`prog-${i}`);
                        if(fill) { fill.style.width='0%'; fill.style.transition=`width ${BAR_TIME}s linear`; fill.style.width='100%'; }
                    }, (start - audioCtx.currentTime) * 1000);

                    // â˜…â˜…â˜… ê°ì •ì— ë”°ë¥¸ ì—°ì£¼ ì£¼ë²• ë¶„ê¸° â˜…â˜…â˜…
                    if (isSoftMode) {
                        // [ìŠ¬í””/ëª½í™˜]: ì•„ë¥´í˜ì§€ì˜¤ ì£¼ë²• + ë² ì´ìŠ¤ ë¡±í†¤
                        playGuitarArpeggio(chord, start);
                        playBass(root, start, BAR_TIME, true);
                        
                        // ë“œëŸ¼: ì•„ì£¼ ì•½í•˜ê²Œ í‹±.. í‹±..
                        playDrum('hat', start, 0.3);
                        playDrum('hat', start + BEAT_TIME*2, 0.3);
                    } else {
                        // [í–‰ë³µ/ì‹ ë‚¨/ì‚¬ë‘]: ê¸°ì¡´ì˜ ë¦¬ë“¬ ìŠ¤íŠ¸ëŸ¼ + ì¿µì§ ë“œëŸ¼
                        // Groove Drum
                        playDrum('kick', start); playDrum('kick', start+BEAT_TIME*1.5); playDrum('kick', start+BEAT_TIME*2.5);
                        playDrum('snare', start+BEAT_TIME); playDrum('snare', start+BEAT_TIME*3);
                        setTimeout(()=> playDrum('snare', start + BEAT_TIME * 3.75, 0.3), (start + BEAT_TIME * 3.75 - audioCtx.currentTime)*1000);
                        for(let h=0; h<4; h+=0.25) playDrum('hat', start+BEAT_TIME*h, (h%1===0)?0.6:0.2);
                        
                        // Guitar Strum
                        playGuitarStrum(chord, start+BEAT_TIME*0.5); playGuitarStrum(chord, start+BEAT_TIME*1.5);
                        playGuitarStrum(chord, start+BEAT_TIME*2.5); playGuitarStrum(chord, start+BEAT_TIME*3.5);
                        
                        // Bass Rythmn
                        playBass(root, start, BEAT_TIME*0.75); 
                        let fifth = notesScale[(notesScale.indexOf(root)+7)%12];
                        playBass(fifth, start+BEAT_TIME*1.5, BEAT_TIME*0.5);
                        playBass(root, start+BEAT_TIME*3.5, BEAT_TIME*0.5, true);
                    }
                });
            }

            melodyData.forEach(m => {
                playSynthLead(m.note, masterStartTime + m.relStart, m.duration);
            });

            setTimeout(() => { 
                stopEverything();
                updateMsg("ì „ì²´ ì¬ìƒ ì™„ë£Œ."); 
                document.querySelectorAll('.progress-fill').forEach(el => {el.style.transition='none'; el.style.width='0%'});
                showGuide(currentChords[0], 0);
            }, totalDuration * 1000 + 2000);
        }

        document.querySelectorAll('.key').forEach(k => {
            let note = k.getAttribute('data-note');
            let fn = (e) => {
                e.preventDefault(); 
                if(!audioCtx) appStart();
                if(audioCtx.state === 'suspended') audioCtx.resume();

                if(isStandby) { isStandby = false; isRecording = true; startRecordingStep(); }

                k.classList.add('active');
                
                let playNote = note;
                if(isAutoTune && (isRecording || isStandby)) {
                    let timeInSong = (sectionCount * 4 * BAR_TIME) + (currentStep * BAR_TIME);
                    playNote = getSmartSafeNote(note, timeInSong); 
                    visualizeMagic(playNote); 
                }
                
                playSynthLead(playNote, audioCtx.currentTime, 0); 
                
                if(isRecording) {
                    let sectionOffset = sectionCount * (BAR_TIME * 4);
                    let barOffset = currentStep * BAR_TIME;
                    let relTimeInBar = audioCtx.currentTime - recStartTime;
                    relTimeInBar -= 0.1; if(relTimeInBar < 0) relTimeInBar = 0;
                    if (relTimeInBar < BAR_TIME) {
                        let totalAbsTime = sectionOffset + barOffset + relTimeInBar;
                        let data = {note: playNote, relStart: totalAbsTime, duration: 0.5};
                        melodyData.push(data);
                    }
                }

                let up = () => {
                    k.classList.remove('active');
                    k.removeEventListener('mouseup', up); k.removeEventListener('touchend', up); k.removeEventListener('mouseleave', up);
                };
                k.addEventListener('mouseup', up); k.addEventListener('touchend', up); k.addEventListener('mouseleave', up);
            };
            k.addEventListener('mousedown', fn); k.addEventListener('touchstart', fn);
        });

        function visualizeMagic(note) {
            document.querySelectorAll('.key').forEach(k => k.classList.remove('magic-hit'));
            let targetKey = document.querySelector(`.key[data-note="${note.replace(/[0-9]/g,'')}"]`);
            if (!targetKey) targetKey = document.querySelector(`.key[data-note="${note.replace(/[0-9]/g,'')+"2"}"]`);
            if (targetKey) {
                targetKey.classList.add('magic-hit');
                setTimeout(() => targetKey.classList.remove('magic-hit'), 200);
            }
        }

        function toggleAutoTune() { 
            isAutoTune = !isAutoTune; 
            document.getElementById('autoTuneBtn').classList.toggle('on'); 
            updateMsg(isAutoTune ? "ğŸª„ í”„ë¡œë“€ì„œ ë„ê¹¨ë¹„ ON! (í‹€ë¦° ìŒ ìë™ ë³´ì •)" : "ê¸°ë³¸ ëª¨ë“œ (ë³´ì • ì—†ìŒ)");
            showGuide(currentChords[currentStep], currentStep);
        }
        function updateMsg(t) { document.getElementById('statusMsg').innerText = t; }
        
        function getFreq(note) { const f = {'C':261.6,'C#':277.1,'D':293.6,'D#':311.1,'E':329.6,'F':349.2,'F#':369.9,'G':392.0,'G#':415.3,'A':440.0,'A#':466.1,'B':493.8}; if(note.includes('2')) return (f[note.replace('2','')]||261.6)*2; return f[note]||261.6; }
        function saveLog() { const t=document.getElementById('q1').value; const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([t])); a.download='music_log.txt'; a.click(); }
        function exportAudio() { if(!audioCtx)return; const btn=document.querySelector('.save-btn'); btn.innerText="ë…¹ìŒ ì¤‘..."; let c=[]; let r=new MediaRecorder(destNode.stream); r.ondataavailable=e=>c.push(e.data); r.onstop=()=>{const u=URL.createObjectURL(new Blob(c,{type:'audio/webm'})); const a=document.createElement('a'); a.style.display='none'; a.href=u; a.download='Band.webm'; document.body.appendChild(a); a.click(); btn.innerText="ğŸ’¾ ì €ì¥";}; r.start(); playEnsemble(); 
            let lastNoteTime = 0; melodyData.forEach(m => { if(m.relStart > lastNoteTime) lastNoteTime = m.relStart; });
            let totalDuration = Math.ceil(Math.max(lastNoteTime, 0.1) / (BAR_TIME*4)) * (BAR_TIME*4);
            if (totalDuration < BAR_TIME*4) totalDuration = BAR_TIME*4;
            setTimeout(()=>r.stop(), totalDuration*1000 + 2000); 
        }

        // â˜…â˜…â˜… ì•„ë¥´í˜ì§€ì˜¤(ë¶„ì‚°í™”ìŒ) ì—°ì£¼ í•¨ìˆ˜ ì¶”ê°€ë¨ â˜…â˜…â˜…
        function playGuitarArpeggio(chord, time) {
            let root = chord.replace('m','');
            let isMinor = chord.includes('m');
            let rootIdx = notesScale.indexOf(root);
            
            let notes = [
                rootIdx, 
                (rootIdx + (isMinor ? 3 : 4)) % 12, 
                (rootIdx + 7) % 12, 
                rootIdx + 12
            ];
            
            let timings = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]; 
            let patterns = [0, 2, 1, 2, 0, 2, 1, 2]; 

            timings.forEach((t, i) => {
                let noteIdx = notes[patterns[i]];
                let freq = getFreq(notesScale[noteIdx%12]);
                if (patterns[i] === 3) freq *= 2; 
                
                let osc = audioCtx.createOscillator();
                let g = audioCtx.createGain();
                osc.type = 'triangle'; 
                osc.frequency.value = freq;
                
                osc.connect(g); g.connect(bandGain);
                
                let noteTime = time + (t * BEAT_TIME);
                g.gain.setValueAtTime(0, noteTime);
                g.gain.linearRampToValueAtTime(0.3, noteTime + 0.05); 
                g.gain.exponentialRampToValueAtTime(0.01, noteTime + 0.6); 
                
                osc.start(noteTime);
                osc.stop(noteTime + 0.7);
            });
        }
        
        function playGuitarStrum(chord, time) { let root=chord.replace('m',''); let m=chord.includes('m'); let f1=getFreq(root)*2; let f2=getFreq(notesScale[(notesScale.indexOf(root)+(m?3:4))%12])*2; const drive=audioCtx.createWaveShaper(); drive.curve=makeDistortionCurve(50); drive.oversample='4x'; const gain=audioCtx.createGain(); gain.gain.setValueAtTime(0.1, time); gain.gain.exponentialRampToValueAtTime(0.01, time+0.2); drive.connect(gain); gain.connect(bandGain); [f1,f2].forEach((f,i)=>{let osc=audioCtx.createOscillator();osc.type='sawtooth';osc.frequency.value=f;osc.connect(drive);osc.start(time);osc.stop(time+0.2);}); }
        function makeDistortionCurve(k) { let n=44100,c=new Float32Array(n),d=Math.PI/180; for(let i=0;i<n;++i){let x=i*2/n-1;c[i]=(3+k)*x*20*d/(Math.PI+k*Math.abs(x));}return c;}
        function playBass(n,t,d,h=false) { let o=audioCtx.createOscillator();let g=audioCtx.createGain();let f=audioCtx.createBiquadFilter();o.type='square';o.frequency.value=getFreq(n)/(h?1:2);f.type='lowpass';f.frequency.value=800;o.connect(f);f.connect(g);g.connect(bandGain);g.gain.setValueAtTime(0.6,t);g.gain.exponentialRampToValueAtTime(0.01,t+d);o.start(t);o.stop(t+d);}
        function playDrum(n,t,v=1.0) { let o=audioCtx.createOscillator();let g=audioCtx.createGain();if(n=='kick'){o.frequency.setValueAtTime(150,t);o.frequency.exponentialRampToValueAtTime(0.01,t+0.5);g.gain.setValueAtTime(1.0*v,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.5);o.connect(g);g.connect(bandGain);o.start(t);o.stop(t+0.5);}else if(n=='snare'){let b=audioCtx.createBuffer(1,44100*0.1,44100);let d=b.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;let src=audioCtx.createBufferSource();src.buffer=b;let f=audioCtx.createBiquadFilter();f.type='highpass';f.frequency.value=1000;src.connect(f);f.connect(g);g.connect(bandGain);g.gain.setValueAtTime(0.7*v,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.1);src.start(t);}else{let b=audioCtx.createBuffer(1,44100*0.05,44100);let d=b.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;let src=audioCtx.createBufferSource();src.buffer=b;let f=audioCtx.createBiquadFilter();f.type='highpass';f.frequency.value=6000;src.connect(f);f.connect(g);g.connect(bandGain);g.gain.setValueAtTime(0.3*v,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.05);src.start(t);}}
    </script>
</body>
</html>
